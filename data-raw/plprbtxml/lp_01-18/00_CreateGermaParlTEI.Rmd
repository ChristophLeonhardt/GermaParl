---
title: "YOUR PROJECT"
author: "YOUR NAME"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{TITLE}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

## Getting started

```{r load_frap}
required_package_version <- "0.4.1"
if (packageVersion("frappp") < as.package_version(required_package_version))
  stop("version requirement not met")
```

```{r load_frap}
library(frappp)
packageVersion("frappp")
```


## Getting input files

```{r, eval = TRUE}
xml_repo_dir <- "~/Lab/gitlab/plprbtxml"
```



## Define parser

```{r}
library(R6)
library(xml2)
library(magrittr)
library(pbapply)
```

```{r}
GermaParlParser <- R6Class(
  
  "GermaParlParser",
  inherit = PlenaryProtocolParser,
  
  public = list(
    
    xmldoc = NULL, # class 'xml_document' from packabe 'xml2'
    download_report = NULL, # a data.frame
    
    initialize = function(download_report_file){
      
      self$download_report <- read.table(file = download_report_file, stringsAsFactors = FALSE)
      rownames(self$download_report) <- gsub(
        "^.*?/pp(\\d+)-data.zip$", "\\1", self$download_report[,1]
        ) %>% as.integer() %>% as.character()
      self$download_report <- self$download_report[as.integer(rownames(self$download_report)),]
      colnames(self$download_report) <- c("url", "date", "time")
      
      self$xpath <- teiXpath

      invisible(self)
    },
    
    read_file = function(filename, id){
      self$id <- id
      self$xmldoc <- xml2::read_xml(x = filename)
      self$txt <- xml2::xml_find_first(x = self$xmldoc, xpath = "/DOKUMENT/TEXT") %>%
        xml_text() %>%
        strsplit(x = ., split = "\\n") %>% 
        unlist()
      invisible(self)
    },
    
    get_metadata = function(download_report){
      lp <- xml2::xml_find_first(x = self$xmldoc, xpath = "/DOKUMENT/WAHLPERIODE") %>%
        xml_text() %>%
        as.integer()
      no <- xml2::xml_find_first(x = self$xmldoc, xpath = "/DOKUMENT/NR") %>%
        xml_text() %>%
        gsub("^\\d+/(\\d+)$", "\\1", .) %>%
        as.integer()
      date <- xml2::xml_find_first(x = self$xmldoc, xpath = "/DOKUMENT/DATUM") %>%
        xml_text()
        as.Date(date, format = "%d.%m.%Y")
      list(
        legislativePeriod = lp,
        sessionNo = no,
        date = date,
        url = self$download_report[as.character(lp), "url"],
        retrievalDate = as.Date(self$download_report[as.character(lp), "date"]),
        package = "frappp",
        version = packageVersion("frappp"),
        birthday = Sys.Date()
        )
    },

    xmlify = function(){
    }
  )
)
```





## Configure the parser

We need to construct the regex for parliamentarians in advance ... 

```{r}
auxfiles_dir <- "~/Lab/github/GermaParl/data-raw/auxfiles"

agenda_item_regex <- eval(parse(file.path(auxfiles_dir, "agenda_item_regex.R")))
genda_item_regex_supplement <- eval(parse(file.path(auxfiles_dir, "agenda_item_regex_supplement.R")))
agenda_item_mismatch <- eval(parse(file.path(auxfiles_dir, "agenda_item_mismatch.R")))
agenda_item_types <- eval(parse(file.path(auxfiles_dir, "agenda_item_types.R")))

preprocessing_functions <- eval(parse(file.path(auxfiles_dir, "preprocessing_functions.R")))
speaker_alias <- eval(parse(file.path(auxfiles_dir, "speaker_alias.R")))
speaker_mismatch <- eval(parse(file.path(auxfiles_dir, "speaker_mismatch.R")))
```


```{r}
source("~/Lab/gitlab/GermaParl/data-raw/plprbtxml/parliamentary_groups_regex.R")
pg_regex_2 <- paste(sprintf("\\s*%s\\s*", unname(pg_regex)), collapse = "|")
mp_regex <- sprintf("^\\s*(?!\\()(?!(Vizepräsident|Präsident))(?!.*?Parl\\.\\s+Staatssekretär)(.+?)\\s*\\((%s)\\)(|\\s*\\(von\\s.*?mit Beifall be\\s?grüßt\\))\\s*:\\s*(.*?)$", pg_regex_2)
```


```{r}
GPP <- GermaParlParser$new(download_report_file = file.path(xml_repo_dir, "download_report.csv"))

GPP$speaker_regex <- list(
  
  pres = list(
    regex = "^\\s*(?!\\()(P|Vizep|Altersp)räsident(|in)\\s+(?!des\\sSenats)([^!,]*?):\\s*(.*)$",
    fn = function(x){
      data.frame(
        who = x[,4],
        parliamentary_group = if (nrow(x) >= 1) "NA" else character(),
        role = if (nrow(x) >= 1) "presidency" else character(),
        position = if (nrow(x) >= 1) sprintf("%sräsident%s", x[,2], x[,3]) else character(),
        text = x[,5],
        stringsAsFactors = FALSE
      )
    }
  ),
  
  mp = list(
    regex = mp_regex,
    fn = function(x){
      data.frame(
        who = x[,3],
        parliamentary_group = x[,4],
        role = if (nrow(x) >= 1) "mp" else character(),
        position = if (nrow(x) >= 1) "NA" else character(),
        text = x[,6],
        stringsAsFactors = FALSE
      )
    }
  ),
  
  gov = c(
    regex = "^\\s*(?!\\()([^!]+?),\\s(Bundeskanzler|Bundesminister|Staatsminister\\s+(?!\\()|Staatsministerin\\s+(?!\\()|Staatssekretär|Parl\\.\\s+Staatssekretär|Beauftragter?\\sder\\sBundesregierung)([^!]*?)(|\\s*\\(vo[nm]\\s.*?mit Beifall be\\s?grüßt\\)):\\s*(.*?)$",
    fn = function(x) data.frame(
      who = x[,2],
      parliamentary_group = if (nrow(x) >= 1) "NA" else character(),
      role = if (nrow(x) >= 1) "government" else character(),
      position = sprintf("%s%s", x[,3], x[,4]),
      text = x[,6],
      stringsAsFactors = FALSE
    )
  ),
  
  state_a = c(
    regex="^\\s*(?!\\()(Präsident\\sdes\\Senats|Präsidentin\\sdes\\sSenats|Ministerpräsident|Ministerpräsidentin|Staatsminister|Staatsministerin)\\s+(.*?)\\s+(\\(.*?\\))(|\\s*\\(vo[nm]\\s.*?mit Beifall be\\s?grüßt\\)):(.*?)$",
    fn = function(x) data.frame(
      who = x[,3],
      parliamentary_group = if (nrow(x) >= 1) "NA" else character(),
      role = if (nrow(x) >= 1) "federal_council" else character(),
      position = x[,4],
      text = x[,6],
      stringsAsFactors = FALSE
    )
  ),
  
  state_b = c(
    regex = "^\\s*(?!\\()(.*?),\\s*(Minister|Ministerin|Staatsminister|Staatsministerin|Ministerpräsident|Ministerpräsidentin)\\s*(\\(.*?\\))\\s*(|\\s*\\(vo[nm]\\s.*?mit Beifall be\\s?grüßt\\)):(.*?)$",
    fn = function(x) data.frame(
      who = x[,2],
      parliamentary_group = if (nrow(x) >= 1) "NA" else character(),
      role = if (nrow(x) >= 1) "federal_council" else character(),
      position = x[,3],
      text = x[,6],
      stringsAsFactors = FALSE
    )
  ),
  
  comm = list(
    regex = "^\\s*(?!\\()(.*),\\s+Wehrbeauftragte(r|)\\sdes\\sDeutschen\\sBundestag(e|)s:(.*?)$",
    fn = function(x) data.frame(
      who = x[,2],  
      parliamentary_group = if (nrow(x) >= 1) "NA" else character(),
      role = if (nrow(x) >= 1) "parliamentary_commissioner" else character(),
      position = if (nrow(x) >= 1) "Wehrbeauftragter des Deutschen Bundestags" else character(),
      text = x[,4],
      stringsAsFactors = FALSE
    )
  )
  
)


GPP$speaker_mismatch <- speaker_mismatch

GPP$agenda_item_regex <- agenda_item_regex
GPP$agenda_item_types <- agenda_item_types

GPP$stage_regex <- c(interjection = "^\\s*\\(.*?\\)\\s*$")
GPP$stage_match_n_lines <- 2L
```





```{r processing_multiple_docs, message = FALSE}
teidir <- "/Users/blaette/Lab/tmp/NewGermaParlTEI"
files <- Sys.glob(paths = sprintf("%s/18/*.xml", xml_repo_dir))
files <- sample(x = files, size = 5)
# files <- file.path(xmldir, "01001.xml")
# files <- head(files, n = 200L)

y <- pblapply(
  files,
  function(xmlfile){
    # message(xmlfile)
    GPP$read_file(filename = xmlfile, id = basename(xmlfile))
    GPP$metadata <- GPP$get_metadata()
    GPP$make_header()
    GPP$split_by_speakers()
    GPP$detect_stage_regex_matches()
    GPP$reconstruct_paragraphs(exclude = "pres")
    GPP$make_body()
    writeLines(
      text = as.character(GPP$xml),
      con = file.path(teidir, basename(xmlfile))
    )
    GPP$chunk_data
  }
  )
df <- data.frame(do.call(rbind, y))
```

Reduktion dieser Tabelle (718653 Zeilen / 7 Spalten) auf 'unique' Sprecher.

```{r}
df_min <- plyr::ddply(
  .data = df, .variables = c("who", "parliamentary_group", "role"),
  .fun = function(x) x[1,], .progress = "text"
  )
```

